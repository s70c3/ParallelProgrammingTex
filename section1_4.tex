{ %section1_4
	\par In parallel programs, the developer often faces the problem of synchronization between threads. As a rule, problems arise when accessing memory and at the same time executing some critical sections of code - critical sections.
	\par\textbf{Critical area} is the section of the program, which must be executed with the exclusive right of access to shared data referenced in this program. A process preparing to enter a critical area may be delayed if any other process is in progress at that time in a similar critical area. 
	\par This section will discuss in detail thread synchronization mechanisms at the program level.
	\par The following methods are available for solving thread synchronization problems:
		\begin{itemize}
			\item\textbf{Atomic operations} are operations that are performed in their entirety or not at all. For example, a transaction to a database is an atomic operation. When two threads try to increment the same memory cell out of sync, the value can increase by 2, or maybe 1, depending on the behavior of the threads, since the increment operation is at least 3 assembler instructions. To avoid this, it is worth declaring the data type atomic (if there is one in this programming language / library). A special case of atomic operations is read-modify-write operations: compare-and-swap, test-and-set, fetch-and-add. The problem of the implementation of atomic operations will be raised in more detail in the section.\\~\ref{atomic:section} \textit{Atomic operations in a multithreaded program}.
			\item\textbf{Semaphore} - an object that limits the number of threads that can enter this area of code. Typically, this number is set when the semaphore is initialized. Then, when capturing a semaphore by a thread, the number of threads that captured the semaphore is checked. If the maximum number of threads is reached, then the thread will wait until some of the threads that entered the code area release it. Often the use of semaphores is unjustified, since the overhead of creating and maintaining a semaphore is large. You should also avoid the "semaphore leak" a situation in which the thread does not exit the semaphore when the code area completes execution if the programmer forgot to free the resource.
			\item\textbf{Reader/writer semaphore} пives the threads \textit{only} read or write permissions, and while writing data to one thread, the rest of the threads do not have access to the resource. However, in such semaphores there may be a problem \textit{resource starvation}, in which while streams will read data, other streams will not be able to write data for a long period of time or vice versa. A particular solution to this problem with equal priority of threads can be sequential access of threads in the queue to access and write.
			\item\sloppy{\textbf{Mutex} is a special case of a semaphore, in which only one thread can capture a given area of code. If the mutex serves several critical sections, only one thread can be in any of the critical sections. It is often used in the organization of critical section management, since it is "lighter" than the classical semaphore (it is enough to store one boolean variable instead of a counter), but unlike it, it is assumed that the same stream will capture and release the mutex. It should be noted that in the C++11, in addition to the standard mutex, there are various modifications of it: \textit{recursive\textunderscore mutex} - mutex that allow re-entry into the critical section by the same stream.  \textit{timed\textunderscore mutex} - мmutex with capture timer, and \textit{recursive\textunderscore timed\textunderscore mutex}, combining the advantages of both versions.}
			\item\textbf{Spinlock} is a  lock in which a thread in a loop waits for a resource to free. It is not always the optimal solution, since the waiting thread works while waiting. Inside the code section, thread interruptions must be avoided to avoid deadlock.
			\item\textbf{Seqlock} - synchronization mechanism designed to quickly record a variable in multiple threads. The Linux kernel works as follows: the thread waits until the critical section is released (spinlock); when entering the section, the counter increments, the stream does its work. When exiting a section, the flow checks the counter value. If the counter value has not changed, it means that no one has written data at the moment and the stream exits the critical section, otherwise it reads the value of the variable again.
			\item\textbf{Knuth–Bendix сompletion algorithm} - One of the solutions to synchronization problems is the Knuth-Bendix algorithm from the course of discrete mathematics. With it, you can go from a sequential program to a cascading one. However, this algorithm does not work for all programs; sometimes it can go into an infinite loop or fail.
			\item\textbf{Barier} - a part of code in which the state of threads is synchronized. For example, if a function in the main thread requires all child threads to finish their work, you can put a barrier in front of it. Then it will wait for the completion of the child threads, after which all threads will continue to work. An example of a barrier implementation may be a critical section, the code of which is allowed to be executed only by the last thread that requested execution. The rest of the threads should expect it. To do this, you need to know how many threads should come to the barrier.
			\item\textbf{Non-blocking algorithms.} It is often useful not to use standard locking techniques, but to make the algorithm non-blocking. In this case, the programmer must independently guarantee that critical sections of the code will not be executed simultaneously and the integrity of the shared memory. Another advantage of such algorithms is the safe handling of interrupts. Other synchronization technologies are often used to implement such algorithms: read-modify-write, CAS (see section~\ref{atomic:section}) and etc.
			\item\textbf{RCU (read-copy-update)} - is an algorithm that allows threads to efficiently read data, leaving the data updated at the end of the algorithm, while guaranteeing relevant data. Only one thread can write data, but multiple threads can read data at once. This is achieved, for example, by atomic pointer substitution (CAS). Old versions of the data are stored for past hits, as long as they have at least one pointer. There are newer tools for replacing the pointer: a separate deadlock for writers or the membarrier mechanism used in recent versions of Linux. RCU can be useful in organizing data structures without explicit locks.
			\item\textbf{Monitor} - An object encapsulating a mutex and utility variables to provide secure access to a method or variable by multiple threads. The monitor characterizes that at one moment only one thread can execute any of its methods. For example, if we have a class (in C ++ terms) Account with add methods\textunderscore money(),\\sub\textunderscore money(), it makes sense to make it a monitor so that there are no conflicts when conducting operations with the account.
		\end{itemize}
		\par However, it is not necessary to organize parallel computations using synchronization or locks. Some technologies offer an alternative approach to parallel computing:
		\begin{itemize}
			\item\textbf{Program Transactional Memory} - a memory model in which operations performed on memory cells are atomic. Advantages of use: ease of use (enclosing code blocks in a transaction block), lack of locks, however, if used incorrectly, performance may drop, as well as the inability to use operations that cannot be undone inside a transaction block. In the compiler, GCC is supported since version 4.7 as follows:
				\begin{enumerate}
					\item\textunderscore \textunderscore transaction\textunderscore atomic \{ … \} — an indication that the code block is a transaction;
					\item\textunderscore \textunderscore transaction\textunderscore relaxed \{ … \} — an indication that the unsafe code inside the block does not lead to side effects;
					\item\textunderscore \textunderscore transaction\textunderscore cancel — explicit transaction cancellation;
					\item attribute((transaction\textunderscore safe)) — indication of a transaction-safe function;
					\item attribute((transaction\textunderscore pure)) — indication of function without side effects.
				\end{enumerate}
			\item\textbf{Actor model} - a mathematical model of parallel computing, in which the program is an actor objects that interact with each other and can create new actors, send and send messages to each other. The parallelism of computations within one actor is assumed. Each actor has an address to which you can send a message. Each actor works in a separate thread. The actor model is used to organize email, some SOAP web services, and etc.
		\end{itemize}
	\par Despite the large number of synchronization methods, it is most often necessary to proceed from the problem being solved. For example, if we want to make a general incremental integer variable for several threads, it makes no sense to create a mutex or semaphore, it is more optimal to make the variable atomic. Always consider the overhead of creating locks and development time.
}